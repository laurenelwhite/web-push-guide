<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Web Push Notifications – How They Work and Best Practices</title>
  <style>
    body { margin: 0; padding: 0; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif; line-height: 1.6; color: #333; }
    .container { max-width: 800px; margin: 0 auto; padding: 2rem; }
    h1 { font-size: 2em; margin: 0.5em 0 0.5em 0; }
    h2 { font-size: 1.5em; margin: 1.5em 0 0.5em 0; }
    h3 { font-size: 1.25em; margin: 1.2em 0 0.5em 0; }
    p { margin: 0.8em 0; }
    ul, ol { margin: 0.8em 0 0.8em 1.2em; }
    pre { background: #f6f8fa; padding: 0.6em; border-radius: 4px; overflow-x: auto; }
    code { font-family: Menlo, Consolas, Monaco, Liberation Mono, Courier, monospace; background: #f6f8fa; padding: 0.2em 0.4em; border-radius: 4px; }
    blockquote { background: #f9f9f9; border-left: 4px solid #ccc; margin: 1em 0; padding: 0.5em 1em; }
    blockquote p { margin: 0; }
    a { color: #0366d6; text-decoration: none; }
    a:hover { text-decoration: underline; }
    figure { text-align: center; margin: 1em 0; }
    figcaption { font-size: 0.9em; color: #555; margin-top: 0.5em; }
    img { max-width: 100%; height: auto; }
  </style>
</head>
<body>
  <article class="container">
    <h1>Web Push Notifications – How They Work and Best Practices</h1>
    <p>Modern web applications can re-engage users with timely updates even after they’ve left the site. This is possible through <strong>web push notifications</strong>, which are brief alerts a website can push to a user’s device via the browser:contentReference[oaicite:0]{index=0}. They appear similar to native app notifications and can be clicked to bring the user back to the site, allowing engagement even when the user is not actively on the webpage:contentReference[oaicite:1]{index=1}. For users, push notifications deliver timely, relevant information; for website owners, they offer a powerful channel to increase user engagement:contentReference[oaicite:2]{index=2}. However, if misused (for example, sending too many or irrelevant messages), push notifications can annoy users and reduce overall engagement:contentReference[oaicite:3]{index=3}. This article will explore what web push notifications are, how they work under the hood, and best practices for using them effectively.</p>

    <h2>What Are Web Push Notifications?</h2>
    <p>Web push notifications are messages that websites send to a user via the web browser. They typically appear as small pop-up banners on a desktop or mobile screen, even if the browser is minimized. A web push notification usually includes a title, some body text, and optionally an icon or image, and is “clickable” – clicking it will open a link (often back to the website). These notifications are delivered in real time through the browser’s notification system, so they can reach the user instantly.</p>
    <p>Importantly, web push notifications are an <em>opt-in</em> channel – a site must first ask and obtain permission from the user to send them. They do not require any personal contact information (such as email or phone number); the only thing needed is the user’s consent via the browser prompt. This makes them a privacy-friendly and cost-effective engagement tool, since users can subscribe anonymously and you don’t need to gather personal data:contentReference[oaicite:4]{index=4}.</p>
    <p>On a technical level, what we call a “push notification” is actually the combination of two web technologies: the <strong>Push API</strong> for receiving messages in the background, and the <strong>Notifications API</strong> for displaying those messages to the user:contentReference[oaicite:5]{index=5}. A website can use the Push API to push data to a user’s browser (even when the site is not open), and then use the Notifications API to show a system notification to the user. Browsers currently require that push messages always result in a visible notification – silent pushes (data delivered with no user-visible alert) are not allowed in mainstream browsers for security and user experience reasons:contentReference[oaicite:6]{index=6}. In practice, when we say “web push notification,” we mean the combined act of pushing a message to the browser and displaying it to the user.</p>

    <h2>Why Use Push Notifications?</h2>
    <p>When used thoughtfully, web push notifications can significantly enhance user engagement and retention. Here are a few key benefits of using push notifications on the web:</p>
    <ul>
      <li><strong>Instant, real-time engagement:</strong> Push notifications let you reach users with time-sensitive alerts (for example, a flash sale announcement or breaking news) the moment they’re available. This real-time engagement makes your communication more relevant and effective:contentReference[oaicite:7]{index=7}.</li>
      <li><strong>Better user retention and conversions:</strong> They provide a channel to re-engage users who have left your site. For instance, you can remind users about an abandoned shopping cart or a dropped form. Approximately 70% of online shopping carts are abandoned without purchase:contentReference[oaicite:8]{index=8} – a timely push notification offering a discount or reminder can help win some of those customers back by prompting them to return and complete the purchase.</li>
      <li><strong>High visibility:</strong> Web push notifications appear directly in the user’s device notification area (on desktop or mobile), so they aren’t easily overlooked. They don’t get buried in email inboxes or filtered into spam. In fact, they bypass email spam filters and even browser ad-blockers, ensuring your message is seen by the user on their screen:contentReference[oaicite:9]{index=9}.</li>
      <li><strong>No app install required:</strong> Unlike mobile app notifications, web push works through the browser – users don’t need to download a native app. This lowers the barrier to reaching your audience. A visitor can receive notifications just by opting in on your website, which means you can engage users on both desktop and mobile web without asking for an app download:contentReference[oaicite:10]{index=10}.</li>
    </ul>

    <h2>Browser Support and Requirements</h2>
    <p>Web push notifications are broadly supported on modern browsers and operating systems. On desktop, Google Chrome, Mozilla Firefox, Microsoft Edge, Safari, Opera, and most other major browsers all support push notifications:contentReference[oaicite:11]{index=11}. On Android devices, browsers like Chrome, Firefox, Opera, and Samsung Internet support web push as well. Until recently, Apple’s browsers were the main missing piece – Safari on macOS supported a proprietary push service in the past, but starting with Safari 16+ (on macOS Ventura) it added support for the standard Web Push API. And as of iOS/iPadOS 16.4 (released in 2023), Safari on iPhone and iPad also supports web push notifications for web apps that the user has added to their home screen:contentReference[oaicite:12]{index=12}:contentReference[oaicite:13]{index=13}. (This means if your website is a Progressive Web App and the user saves it to their home screen, it can send push notifications on iOS, using Apple’s push service under the hood:contentReference[oaicite:14]{index=14}.) In summary, web push now works across most platforms: Windows, macOS, Linux, Android, and iOS – though on iOS there is the caveat that the user must use the Add to Home Screen feature for the site to enable push.</p>
    <p>There are a few technical prerequisites for implementing web push. First, your site must be served over <strong>HTTPS</strong> (secure connection). Browsers only allow the Push API and Service Workers on secure origins, for security reasons. Second, you need a <strong>Service Worker</strong> set up for your site. Service workers are essentially background scripts that run in the browser even when your webpage is closed, and they are required for push notifications to work:contentReference[oaicite:15]{index=15}. The service worker will be responsible for handling incoming push messages and triggering notifications. Finally, of course, the user must grant permission for notifications – without user permission, you cannot send any push notifications to them.</p>

    <h2>How Web Push Notifications Work</h2>
    <p>Under the hood, web push involves coordination between your web app, the user’s browser, and a push service in the cloud. At a high level, the process consists of four main steps:</p>
    <ol>
      <li><em>Request permission from the user.</em></li>
      <li><em>Subscribe the user’s browser to a push service (and send the subscription info to your server).</em></li>
      <li><em>Send push messages from your server to the browser’s push service.</em></li>
      <li><em>Receive the push message in the browser and display a notification to the user.</em></li>
    </ol>
    <p>The following sections describe each of these steps in detail.</p>

    <h3>Step 1: Requesting Notification Permission</h3>
    <p>The first step is to ask the user’s permission to send notifications. Browsers enforce that this permission prompt can only be triggered by a user action (to prevent spam), so you should tie it to a user gesture – for example, a click on a “Subscribe to notifications” button or link. In response to that click (or similar action), your web page can call the JavaScript method <code>Notification.requestPermission()</code> to initiate the permission flow:contentReference[oaicite:16]{index=16}. The browser will then show a native prompt (usually a small panel or dialog provided by the browser or OS) asking the user to allow or block notifications from your site. The user’s choice (granted, denied, or dismissed) will be returned to your code (via the Promise returned by <code>requestPermission()</code> or a callback). You should only proceed to the next step if the permission was granted.</p>
    <p><strong>Best Practice:</strong> Don’t rush to ask for notification permission as soon as a user lands on your site. It’s better to wait until the user has shown some interest or there’s a contextually relevant reason to prompt. Requesting permission too early (like on first page load) can feel intrusive and often leads to the user denying the request:contentReference[oaicite:17]{index=17}. Instead, ask at a moment when the value of subscribing is clear (for example, after a user signs up, or when they’ve been browsing for a while and might want updates).</p>

    <h3>Step 2: Subscribing the User to Push Service</h3>
    <p>Once the user has granted notification permission, the next step is to create a push subscription for that user’s browser. This involves registering a service worker (if you haven’t already) and then using the <code>Push API</code> to subscribe. In practice, you’ll call <code>registration.pushManager.subscribe()</code> from your page’s script (where <code>registration</code> is the Service Worker registration object). This tells the browser to set up a new push subscription with its backend push service:contentReference[oaicite:18]{index=18}. You will need to supply an application <em>public key</em> (specifically, a VAPID public key) when calling subscribe, which helps identify your application and secure the subscription:contentReference[oaicite:19]{index=19}.</p>
    <p>If the subscription is successful, the browser returns a <code>PushSubscription</code> object. This object contains all the information your server will need to send push messages to this specific user – notably an <code>endpoint URL</code> (a unique address of the browser’s push service for this subscription) and a pair of encryption keys. You should send this subscription object (or its JSON representation) to your own backend server and save it in a database:contentReference[oaicite:20]{index=20}, so that later your server can trigger push messages to this user.</p>
    <p>For example, a new push subscription might look something like this:</p>
    <pre><code>{
  "endpoint": "https://fcm.googleapis.com/fcm/send/c1KrmpTuRm…",
  "expirationTime": null,
  "keys": {
    "p256dh": "BGyyVt9FFV…",
    "auth": "R9sidzkcdf…"
  }
}</code></pre>
    <p>The <code>endpoint</code> is the address of the push service (in this case, a URL to Google’s Firebase Cloud Messaging service, used by Chrome) along with an identifier for the specific subscription on that service. The <code>keys</code> (a public key <code>p256dh</code> and an <code>auth</code> secret) are used to encrypt and authenticate the messages sent to this subscription, ensuring security and privacy. The browser’s push service will expect any push message sent to this <code>endpoint</code> to be encrypted with the provided keys.</p>
    <figure>
      <img src="https://web.dev/static/articles/push-notifications-overview/image/get-permission-send-push-bd9323129e7a5.svg" alt="Diagram showing requesting permission, obtaining a PushSubscription, and sending the subscription to the server" />
      <figcaption>Figure 1: The client-side flow for subscribing a user. The website first requests notification permission, then uses the Push API to get a <code>PushSubscription</code> from the browser’s push service, and finally sends the subscription details to the application server for storage:contentReference[oaicite:21]{index=21}:contentReference[oaicite:22]{index=22}.</figcaption>
    </figure>

    <h3>Step 3: Sending Push Messages from Your Server</h3>
    <p>Now that your server has the user’s subscription details, it can send push notifications to that user. It’s important to understand that your server does not send data directly to the user’s device. Instead, it sends the message to a <strong>push service</strong> – a cloud service operated by the browser vendor – which then delivers the message to the device on your behalf:contentReference[oaicite:23]{index=23}. The subscription’s <code>endpoint</code> URL tells you which push service to use and includes the unique identifier for the user’s device on that service.</p>
    <p>All browser push services implement a common protocol (the <em>Web Push Protocol</em>) for how they expect to receive push requests:contentReference[oaicite:24]{index=24}. This means you don’t have to worry about the differences between, say, Google’s and Mozilla’s push servers – as long as you send a properly formatted Web Push HTTP request, any compliant push service will understand it. Typically, your server will issue an HTTPS POST request to the subscription’s endpoint URL. This request includes the notification data (often a JSON payload) and headers containing encryption and authentication information.</p>
    <p>Because push messages may contain sensitive information, they must be encrypted on the server side before sending. The browser provided encryption keys (like <code>p256dh</code> and <code>auth</code>) are used to encrypt the message payload so that the push service itself cannot read the content of the notification:contentReference[oaicite:25]{index=25}. This end-to-end encryption ensures privacy – the push service simply acts as a relay.</p>
    <p>Additionally, to prevent abuse, browsers require that push messages be authenticated. This is usually done using <strong>VAPID</strong> (Voluntary Application Server Identification) keys:contentReference[oaicite:26]{index=26}. When you set up your server for push, you generate a VAPID public/private key pair (this is a one-time setup). The public key is the one you pass into the browser when subscribing (as mentioned in Step 2). The private key is kept on your server. When sending a push message, your server uses its private key to sign the request. The push service will verify this signature using the public key associated with the subscription’s endpoint:contentReference[oaicite:27]{index=27}. If the signature is valid, the push service knows the request actually came from your server (and not an imposter), because only your server has the corresponding private key.</p>
    <p>Most developers will use a helper library rather than manually crafting HTTP requests for web push. There are open-source libraries (for example, the <code>web-push</code> library for Node.js and similar libraries for other languages) that take care of constructing the request with the proper headers, encryption, and VAPID signature:contentReference[oaicite:28]{index=28}. With such a library, you typically just provide the <code>PushSubscription</code> object (from Step 2) and the payload data, and the library handles the rest of the protocol under the hood.</p>
    <p>When your server sends the push request, the push service will queue and route the message to the user’s device. If the device is online at that moment, the message is usually delivered immediately. If the device (or browser) is offline, the push service will hold the message in a queue and deliver it once the browser comes online:contentReference[oaicite:29]{index=29}. You can control some aspects of this delivery by setting options in the push message headers – for example, you can specify a <em>Time-To-Live (TTL)</em>, after which the message should be discarded if not delivered, or mark the message with an <em>urgency</em> level to hint to the push service how important it is:contentReference[oaicite:30]{index=30}. You can even assign a “topic” identifier to allow the push service to coalesce (replace) older, un-delivered messages with newer ones of the same topic, if needed, to save bandwidth.</p>
    <figure>
      <img src="https://web.dev/static/articles/push-notifications-overview/image/your-server-sends-web-pu-55e06fc9c0017.svg" alt="Diagram showing the server sending a push message to the browser's push service, which then delivers it to the user's device" />
      <figcaption>Figure 2: Server-side flow for sending a push notification. Your server sends the notification (with proper encryption and authentication) as a Web Push protocol request to the browser vendor’s push service. The push service then routes the message to the correct user device and queues it if the device is offline:contentReference[oaicite:31]{index=31}:contentReference[oaicite:32]{index=32}.</figcaption>
    </figure>

    <h3>Step 4: Receiving the Notification in the Browser</h3>
    <p>The final step occurs on the user’s device. When the push service delivers the message, the user’s browser (if it’s running, or the next time it starts up) will receive the incoming push message. This awakens the service worker associated with your website and dispatches a <code>'push'</code> event to that service worker:contentReference[oaicite:33]{index=33}. In your service worker code, you can listen for this event and decide how to handle the push message. Typically, you will extract any data that was sent (the Push API allows a small data payload to be included) and then display a notification to the user using the Notifications API.</p>
    <p>Here’s a simplified example of a service worker handling an incoming push event and showing a notification:</p>
    <pre><code>self.addEventListener('push', (event) =&gt; {
  // Extract data (if any) from the event
  const messageData = event.data ? event.data.text() : '(no payload)';
  const options = {
    body: messageData,
    icon: '/images/icon.png'
    // You can add other notification options like tag, actions, etc.
  };
  event.waitUntil(
    self.registration.showNotification('New Notification', options)
  );
});</code></pre>
    <p>In the above code, when a push is received, we create a notification with a title (<em>“New Notification”</em>) and use the payload text as the body. We also specify an icon. The <code>event.waitUntil()</code> is used to ensure the service worker stays alive long enough to display the notification. In a real-world scenario, you might want to include more context in the notification (for example, open a specific URL when clicked, which can be handled in a <code>'notificationclick'</code> event listener in the service worker).</p>
    <p>Once <code>showNotification</code> is called, the browser will display the notification to the user using the standard notification UI of that device/OS. If the user clicks the notification, by default the browser will open your website (or bring it to focus if it’s already open). You can customize this behavior by listening for the <code>'notificationclick'</code> event in the service worker – for instance, you could open a specific page or take some other action when the notification is clicked.</p>
    <figure>
      <img src="https://web.dev/static/articles/push-notifications-overview/image/message-arrives-service-worker-9d70e9b43f806.svg" alt="Diagram showing the browser receiving the push message, waking the service worker, and the service worker displaying a notification" />
      <figcaption>Figure 3: Client-side flow for receiving a push. The push service delivers the message to the browser. The browser wakes up the service worker, which then runs the <code>'push'</code> event handler and typically calls <code>showNotification()</code> to display the notification to the user:contentReference[oaicite:34]{index=34}.</figcaption>
    </figure>

    <h2>Best Practices for Using Web Push</h2>
    <p>Push notifications are a powerful tool – used wisely, they can greatly enhance user experience, but if used poorly, they can drive users away. Here are some best practices to ensure your web push notifications are effective and welcome:</p>
    <ul>
      <li><strong>Always ask for permission (and at the right time):</strong> Only send push notifications to users who have explicitly opted in. Never try to “force” subscriptions, and don’t trick users into granting permission. It’s also important <em>when</em> you ask – do it at a moment of relevance. For example, if your site provides value through notifications (a shipping update, new blog post alert, etc.), ask when the user is likely to appreciate that. If done right, users understand the benefit; if done poorly (asking on first visit with no context), it feels spammy:contentReference[oaicite:35]{index=35}:contentReference[oaicite:36]{index=36}.</li>
      <li><strong>Deliver value with every notification:</strong> Each push notification you send should be useful, timely, and relevant to the user:contentReference[oaicite:37]{index=37}. Users will stay subscribed only if they find your notifications helpful. Avoid sending messages just for the sake of it. For example, a news site might send breaking news alerts (valuable), but should not send trivial updates. If the content isn’t valuable or is too frequent, users will mute notifications or unsubscribe (or browsers may even automatically revoke permission if too many notifications are ignored).</li>
      <li><strong>Be concise and clear:</strong> Keep your notification messages brief and to the point. Use a short, attention-grabbing title and an informative message body. The user should be able to glance at the notification and understand what it’s about and what action (if any) they should take. If applicable, include a call-to-action (for example, “View order status” or “Read now”) in the notification to encourage engagement.</li>
      <li><strong>Respect frequency and timing:</strong> Don’t overload users with notifications. Too many notifications can be as bad as none – they become noise. Limit your send frequency and ideally allow users to customize how often they want to hear from you. Timing matters too: sending notifications at odd hours (like 3AM) can annoy users. Try to send at times when users are likely to engage, and consider time zones. Remember, <em>timing is crucial</em> – the right message at the right moment is far more effective:contentReference[oaicite:38]{index=38}.</li>
      <li><strong>Provide easy ways to opt-out or adjust preferences:</strong> Users should always have control. Make sure it’s clear how a user can unsubscribe from notifications if they no longer want them. This could be as simple as providing instructions (“You can disable notifications in your browser settings or profile preferences”) in an email or on your site’s settings page. Respect user choices – if a user has unsubscribed or not granted permission, do not nag them continuously. Also, keep the permission prompt’s outcome in mind: if a user denied it, don’t immediately prompt them again; give it some time or wait until they take a relevant action that might change their mind.</li>
    </ul>

    <p>In conclusion, web push notifications combine the reach of the web with the engagement power of push messaging. They enable you to deliver timely, pertinent information to your users and can help drive traffic and conversions by bringing users back to your site. Implementing web push does require setup on both the client (browser) and server sides – including service workers, handling user permissions, and integrating with push services – but many libraries and services exist to simplify this. By following best practices and focusing on delivering real value to your users, you can make web push notifications a welcome and effective part of your web application’s engagement strategy.</p>

    <blockquote>
      <p>“If done well, it’s nice to have, but if not done well, it’s really annoying.” — a conversation between two browser developers on the ethics of push notifications:contentReference[oaicite:39]{index=39}</p>
    </blockquote>
  </article>
</body>
</html>
